
module          ::= decl* EOF

decl            ::= type_decl | func_decl | struct_decl | interface_decl | var_decl

type_decl       ::= "type" IDENT type_params? "=" type ";"

type_params     ::= "<" type_param ( "," type_param )* ">"

type_param      ::= IDENT ( ":" type )?

type            ::= prim_type ( "+" prim_type )*

prim_type       ::= "fn" "(" ( param_type ( "," param_type )* )? ")" ( "->" type )?
                  | IDENT ( "<" ( type ( "," type )* )? ">" )?
                  | "?" type

param_type      ::= "inout"? type

func_decl       ::= "fn" IDENT type_params? func_sig block

func_sig        ::= "(" ( param ( "," param )* )? ")" ( "->" type )?

param           ::= IDENT ":" param_type

block           ::= "{" stmt* "}"

struct_decl     ::= "struct" IDENT type_params? "{" ( field ( "," field )* )? "}"

field           ::= IDENT ":" type

interface_decl  ::= "interface" IDENT type_params? ( ":" type )? "{" func_proto* "}"

func_proto      ::= "fn" IDENT func_sig ";"

var_decl        ::= "var" IDENT ":" type ( "=" expr )? ";"
                  | "let" IDENT ( ":" type )? "=" expr ";"

stmt            ::= type_decl
                  | func_decl
                  | struct_decl
                  | interface_decl
                  | var_decl
                  | block
                  | "if" expr block ( "else" block )?
                  | "loop" block
                  | "while" expr block
                  | "do" block "while" expr ";"
                  | "for" IDENT "in" expr block
                  | "break" ";"
                  | "continue" ";"
                  | "return" expr? ";"
                  | expr ";"

expr            ::= or_expr ( assign_op expr )?

assign_op       ::= "=" | "|=" | "^=" | "&=" | "<<=" | ">>=" 
                  | "+=" | "-=" | "*=" | "/=" | "%="

or_expr         ::= and_expr ( "||" and_expr )*

and_expr        ::= eq_expr ( "&&" eq_expr )*

eq_expr         ::= comp_expr ( ( "==" | "!=" ) comp_expr )*

comp_expr       ::= bor_expr ( ( "<" | "<=" | ">" | ">=" ) bor_expr )*

bor_expr        ::= bxor_expr ( "|" bxor_expr )*

bxor_expr       ::= band_expr ( "^" band_expr )*

band_expr       ::= shift_expr ( "&" shift_expr )*

shift_expr      ::= range_expr ( ( "<<" | ">>" ) range_expr )*

range_expr      ::= add_expr ( ".." add_expr )?

add_expr        ::= mul_expr ( ( "+" | "-" ) mul_expr )*

mul_expr        ::= unary_expr ( ( "*" | "/" | "%" ) unary_expr )*

unary_expr      ::= ( "!" | "-" | "~" ) unary_expr | prim_expr

prim_expr       ::= "null" | "false" | "true" | INT | FLOAT | RUNE | STRING
                  | "[" ( expr ( "," expr )* )? "]"
                  | "fn" func_sig block
                  | "new" type call
                  | "&" IDENT subscr*
                  | IDENT ( subscr | call )*
                  | "if" expr "{" expr "}" "else" "{" expr "}"
                  | "(" expr ")"

call            ::= "(" ( expr ( "," expr )* )? ")"

subscr          ::= "[" expr "]" | "." IDENT
