
module          ::= decl* EOF

decl            ::= import_decl
                  | type_decl
                  | func_decl
                  | struct_decl
                  | interface_decl
                  | const_decl

import_decl     ::= "import" STRING ( "as" IDENT )? ";"

type_decl       ::= "type" IDENT type_params? "=" type ";"

type_params     ::= "<" type_param ( "," type_param )* ">"

type_param      ::= IDENT ( ":" type )?

type            ::= prim_type ( "+" prim_type )*

prim_type       ::= "fn" type "(" ( param_type ( "," param_type )* )? ")"
                  | IDENT ( "<" ( type ( "," type )* )? ">" )?

param_type      ::= "inout"? type

func_decl       ::= "fn" IDENT func_sig block

func_sig        ::= type "(" ( param ( "," param )* )? ")"

param           ::= param_type IDENT

block           ::= "{" stmt* "}"

struct_decl     ::= "struct" IDENT type_params? "{" field* "}"

field           ::= type IDENT ";"

interface_decl  ::= "interface" IDENT type_params? ( ":" type )? "{" method_proto* "}"

method_proto    ::= IDENT func_sig ";"

const_decl      ::= "const" IDENT "=" expr ";"

stmt            ::= type_decl
                  | func_decl
                  | struct_decl
                  | interface_decl
                  | const_decl
                  | var_decl
                  | block
                  | "if" expr block ( "else" block )?
                  | "loop" block
                  | "while" expr block
                  | "do" block "while" expr ";"
                  | "for" IDENT "in" expr block
                  | "break" ";"
                  | "continue" ";"
                  | "return" expr? ";"
                  | expr ";"

var_decl        ::= "var" type IDENT ( "=" expr )? ";"

expr            ::= or_expr ( assign_op expr )?

assign_op       ::= "=" | "|=" | "^=" | "&=" | "<<=" | ">>=" 
                  | "+=" | "-=" | "*=" | "/=" | "%="

or_expr         ::= and_expr ( "||" and_expr )*

and_expr        ::= bor_expr ( "&&" bor_expr )*

bor_expr        ::= bxor_expr ( "|" bxor_expr )*

bxor_expr       ::= band_expr ( "^" band_expr )*

band_expr       ::= eq_expr ( "&" eq_expr )*

eq_expr         ::= comp_expr ( ( "==" | "!=" ) comp_expr )*

comp_expr       ::= shift_expr ( ( "<" | "<=" | ">" | ">=" ) shift_expr )*

shift_expr      ::= range_expr ( ( "<<" | ">>" ) range_expr )*

range_expr      ::= add_expr ( ".." add_expr )?

add_expr        ::= mul_expr ( ( "+" | "-" ) mul_expr )*

mul_expr        ::= unary_expr ( ( "*" | "/" | "%" ) unary_expr )*

unary_expr      ::= ( "!" | "-" | "~" ) unary_expr | prim_expr

prim_expr       ::= "void" | "false" | "true" | INT | FLOAT | RUNE | STRING
                  | "[" ( expr ( "," expr )* )? "]"
                  | "fn" func_sig block
                  | "new" type call
                  | "&" IDENT subscr*
                  | IDENT ( subscr | call )*
                  | "try" expr
                  | "if" expr "{" expr "}" "else" "{" expr "}"
                  | "(" expr ")"

call            ::= "(" ( expr ( "," expr )* )? ")"

subscr          ::= "[" expr "]" | "." IDENT
